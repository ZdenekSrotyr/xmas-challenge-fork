name: AI Review and Auto-Merge

on:
  # Trigger when propose-fix workflow completes (avoids GITHUB_TOKEN limitation)
  workflow_run:
    workflows: ["Propose Fix"]
    types: [completed]

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write

jobs:
  ai-review:
    runs-on: ubuntu-latest
    # Only run if propose-fix succeeded
    if: github.event.workflow_run.conclusion == 'success'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Find PR created by propose-fix
        id: find-pr
        uses: actions/github-script@v7
        with:
          script: |
            // Get the workflow run that triggered us
            const runId = context.payload.workflow_run.id;
            const headBranch = context.payload.workflow_run.head_branch;

            console.log(`Triggered by workflow run ${runId} on branch ${headBranch}`);

            // Find open PRs from fix/* branches created by github-actions
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              sort: 'created',
              direction: 'desc',
              per_page: 10
            });

            // Find the most recent PR from a fix/ branch by github-actions
            const targetPR = prs.find(pr =>
              pr.head.ref.startsWith('fix/') &&
              (pr.user.login === 'github-actions[bot]' || pr.user.type === 'Bot')
            );

            if (!targetPR) {
              console.log('No matching PR found from propose-fix workflow');
              core.setOutput('found', 'false');
              return;
            }

            console.log(`Found PR #${targetPR.number}: ${targetPR.title}`);
            core.setOutput('found', 'true');
            core.setOutput('pr_number', targetPR.number);
            core.setOutput('pr_branch', targetPR.head.ref);

            return targetPR;

      - name: Exit if no PR found
        if: steps.find-pr.outputs.found != 'true'
        run: |
          echo "No PR found to review. This can happen if:"
          echo "  - propose-fix didn't create a PR"
          echo "  - PR was already merged/closed"
          echo "Exiting gracefully."
          exit 0

      - name: Set up Python
        if: steps.find-pr.outputs.found == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        if: steps.find-pr.outputs.found == 'true'
        run: |
          pip install --upgrade pip
          pip install anthropic requests

      - name: Get PR details
        id: pr-details
        if: steps.find-pr.outputs.found == 'true'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.find-pr.outputs.pr_number }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);

            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            // Get files changed
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            // Get diff
            const diff = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              mediaType: {
                format: 'diff'
              }
            });

            // Extract issue number from PR body
            const prBody = pr.data.body || '';
            const issueMatch = prBody.match(/\*\*Fixes:\*\*\s*#(\d+)/);
            const issueNumber = issueMatch ? parseInt(issueMatch[1]) : null;

            // Get iteration count from ISSUE labels (not PR labels)
            let currentIteration = 0;
            if (issueNumber) {
              try {
                const issue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                const iterationLabel = issue.data.labels.find(l => l.name.startsWith('ai-iteration-'));
                currentIteration = iterationLabel
                  ? parseInt(iterationLabel.name.replace('ai-iteration-', ''))
                  : 0;
              } catch (e) {
                console.log(`Warning: Could not fetch issue #${issueNumber}: ${e.message}`);
              }
            }

            // Write to files for Python script
            const fs = require('fs');
            fs.writeFileSync('pr-data.json', JSON.stringify({
              number: prNumber,
              title: pr.data.title,
              body: pr.data.body,
              branch: pr.data.head.ref,
              files: files.data.map(f => ({
                filename: f.filename,
                status: f.status,
                additions: f.additions,
                deletions: f.deletions,
                changes: f.changes
              })),
              iteration: currentIteration,
              issue_number: issueNumber
            }, null, 2));

            fs.writeFileSync('pr-diff.txt', diff.data);

            // Output for next steps
            core.setOutput('iteration', currentIteration);
            core.setOutput('issue_number', issueNumber);
            core.setOutput('pr_body', pr.data.body);

            return pr.data;

      - name: AI Review with Claude
        id: ai-review
        if: steps.find-pr.outputs.found == 'true'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          python - <<'EOF'
          import os
          import json
          import sys
          from anthropic import Anthropic

          # Initialize Claude client
          client = Anthropic(api_key=os.environ["ANTHROPIC_API_KEY"])

          # Load PR data
          with open('pr-data.json', 'r') as f:
              pr_data = json.load(f)

          with open('pr-diff.txt', 'r') as f:
              pr_diff = f.read()

          # Prepare review prompt
          iteration = pr_data.get('iteration', 0)
          max_iterations = 2

          prompt = f"""You are an AI code reviewer for a self-healing knowledge base system.

          Review this auto-generated PR and decide what action to take.

          **PR Title:** {pr_data['title']}

          **PR Description:**
          {pr_data['body']}

          **Iteration:** {iteration}/{max_iterations} (this is iteration #{iteration + 1})

          **Files Changed ({len(pr_data['files'])} files):**
          {chr(10).join([f"- {f['filename']} (+{f['additions']} -{f['deletions']})" for f in pr_data['files']])}

          **Diff Preview (first 3000 chars):**
          {pr_diff[:3000]}

          **Review Criteria:**

          1. **Safety Check:**
             - Are ONLY documentation files (docs/keboola/*.md) modified?
             - Are claude/ and gemini/ skills regenerated correctly?
             - No code changes, no workflow changes (unless intentional)?

          2. **Relevance Check:**
             - Do changes address the issue mentioned in PR description?
             - Are changes meaningful and complete?
             - Not just placeholder text?

          3. **Quality Check:**
             - No obvious errors or typos?
             - Proper markdown formatting?
             - Code examples look correct?

          4. **Regeneration Check:**
             - If docs/ changed, are claude/ and gemini/ also updated?
             - Skill files should reflect docs/ changes

          **Decision Options:**
          Respond with a JSON object (ONLY JSON, no markdown):

          {{
            "decision": "MERGE" or "REQUEST_CHANGES" or "NEEDS_REVIEW",
            "confidence": 0-100,
            "reasoning": "Brief explanation of decision",
            "safety_score": 0-100,
            "relevance_score": 0-100,
            "quality_score": 0-100,
            "issues_found": ["list", "of", "issues"] or [],
            "recommendation": "What to do next",
            "improvement_suggestions": ["specific", "actionable", "changes"] or []
          }}

          **Guidelines:**
          - MERGE if: confidence >= 80, safety >= 90, quality >= 80, no critical issues
          - REQUEST_CHANGES if: confidence 60-79, fixable issues, iteration < {max_iterations}
            * Provide specific, actionable improvement_suggestions
            * Issues are minor and can be fixed automatically
          - NEEDS_REVIEW if: confidence < 60, safety < 80, or iteration >= {max_iterations}
            * Issues too complex for automatic fixing
            * Or maximum iterations reached

          **Important:** If iteration is already {max_iterations}, you MUST choose either MERGE or NEEDS_REVIEW (not REQUEST_CHANGES).

          Be specific in improvement_suggestions - these will be sent to Claude AI for automatic fixes.
          """

          try:
              # Call Claude API
              message = client.messages.create(
                  model="claude-sonnet-4-5-20250929",
                  max_tokens=2048,
                  messages=[
                      {"role": "user", "content": prompt}
                  ]
              )

              # Extract response
              response_text = message.content[0].text.strip()

              # Strip markdown if present
              if response_text.startswith('```'):
                  lines = response_text.split('\n')
                  if lines[0].startswith('```'):
                      lines = lines[1:]
                  if lines and lines[-1].strip() == '```':
                      lines = lines[:-1]
                  response_text = '\n'.join(lines).strip()

              # Parse JSON
              review = json.loads(response_text)

              # Validate
              required = ["decision", "confidence", "reasoning", "safety_score", "relevance_score", "quality_score"]
              if not all(key in review for key in required):
                  raise ValueError("Missing required fields in review")

              # Output to GitHub Actions
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write(f"decision={review['decision']}\n")
                  f.write(f"confidence={review['confidence']}\n")
                  f.write(f"reasoning={review['reasoning']}\n")
                  f.write(f"safety_score={review['safety_score']}\n")
                  f.write(f"relevance_score={review['relevance_score']}\n")
                  f.write(f"quality_score={review['quality_score']}\n")

                  # Handle improvement_suggestions
                  if 'improvement_suggestions' in review and review['improvement_suggestions']:
                      suggestions = json.dumps(review['improvement_suggestions'])
                      # Escape newlines and quotes for GitHub Actions
                      suggestions = suggestions.replace('\n', '%0A').replace('\r', '%0D')
                      f.write(f"improvement_suggestions={suggestions}\n")

              # Save full review
              with open('ai-review.json', 'w') as f:
                  json.dump(review, f, indent=2)

              print(f"AI Review: {review['decision']} (confidence: {review['confidence']}%)")
              print(f"Scores - Safety: {review['safety_score']}, Relevance: {review['relevance_score']}, Quality: {review['quality_score']}")

          except json.JSONDecodeError as e:
              print(f"Error: Failed to parse AI response: {e}", file=sys.stderr)
              print(f"Response was: {response_text}", file=sys.stderr)
              # Default to needs review on error
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write(f"decision=NEEDS_REVIEW\n")
                  f.write(f"confidence=0\n")
                  f.write(f"reasoning=AI review failed to parse\n")
              sys.exit(1)
          except Exception as e:
              print(f"Error during AI review: {e}", file=sys.stderr)
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write(f"decision=NEEDS_REVIEW\n")
                  f.write(f"confidence=0\n")
                  f.write(f"reasoning=AI review error\n")
              sys.exit(1)
          EOF

      - name: Post AI Review Comment
        if: steps.find-pr.outputs.found == 'true'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.find-pr.outputs.pr_number }}
          DECISION: ${{ steps.ai-review.outputs.decision }}
          CONFIDENCE: ${{ steps.ai-review.outputs.confidence }}
          REASONING: ${{ steps.ai-review.outputs.reasoning }}
          SAFETY: ${{ steps.ai-review.outputs.safety_score }}
          RELEVANCE: ${{ steps.ai-review.outputs.relevance_score }}
          QUALITY: ${{ steps.ai-review.outputs.quality_score }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);
            const decision = process.env.DECISION;
            const confidence = parseInt(process.env.CONFIDENCE);
            const reasoning = process.env.REASONING;
            const safety = parseInt(process.env.SAFETY);
            const relevance = parseInt(process.env.RELEVANCE);
            const quality = parseInt(process.env.QUALITY);

            // Read full review
            const fs = require('fs');
            let fullReview = {};
            try {
              fullReview = JSON.parse(fs.readFileSync('ai-review.json', 'utf8'));
            } catch (e) {}

            // Create comment
            let comment = `## ðŸ¤– AI Review Results\n\n`;

            if (decision === 'MERGE') {
              comment += `### âœ… **APPROVED FOR AUTO-MERGE**\n\n`;
            } else if (decision === 'REQUEST_CHANGES') {
              comment += `### ðŸ”„ **REQUESTING IMPROVEMENTS**\n\n`;
            } else {
              comment += `### âš ï¸ **NEEDS HUMAN REVIEW**\n\n`;
            }

            comment += `**Confidence:** ${confidence}%\n`;
            comment += `**Reasoning:** ${reasoning}\n\n`;
            comment += `### Scores\n`;
            comment += `- ðŸ›¡ï¸ Safety: ${safety}%\n`;
            comment += `- ðŸŽ¯ Relevance: ${relevance}%\n`;
            comment += `- âœ¨ Quality: ${quality}%\n\n`;

            if (fullReview.issues_found && fullReview.issues_found.length > 0) {
              comment += `### Issues Found\n`;
              fullReview.issues_found.forEach(issue => {
                comment += `- ${issue}\n`;
              });
              comment += `\n`;
            }

            if (fullReview.improvement_suggestions && fullReview.improvement_suggestions.length > 0) {
              comment += `### ðŸ”§ Improvement Suggestions\n`;
              fullReview.improvement_suggestions.forEach(suggestion => {
                comment += `- ${suggestion}\n`;
              });
              comment += `\n`;
            }

            if (fullReview.recommendation) {
              comment += `### Recommendation\n${fullReview.recommendation}\n\n`;
            }

            if (decision === 'MERGE') {
              comment += `---\n\nðŸš€ **Proceeding with automatic merge...**`;
            } else if (decision === 'REQUEST_CHANGES') {
              comment += `---\n\nðŸ”„ **Triggering AI iteration with improvement suggestions...**`;
            } else {
              comment += `---\n\nðŸ‘€ **A human should review this PR before merging.**`;
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: comment
            });

      - name: Auto-merge if approved
        if: steps.find-pr.outputs.found == 'true' && steps.ai-review.outputs.decision == 'MERGE'
        env:
          PR_NUMBER: ${{ steps.find-pr.outputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "âœ… AI approved - merging PR #$PR_NUMBER"
          gh pr merge $PR_NUMBER \
            --squash \
            --delete-branch \
            --repo ${{ github.repository }}

      - name: Request improvements from AI
        if: steps.find-pr.outputs.found == 'true' && steps.ai-review.outputs.decision == 'REQUEST_CHANGES'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.find-pr.outputs.pr_number }}
          PR_BRANCH: ${{ steps.find-pr.outputs.pr_branch }}
          ISSUE_NUMBER: ${{ steps.pr-details.outputs.issue_number }}
          CURRENT_ITERATION: ${{ steps.pr-details.outputs.iteration }}
          IMPROVEMENT_SUGGESTIONS: ${{ steps.ai-review.outputs.improvement_suggestions }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);
            const prBranch = process.env.PR_BRANCH;
            const issueNumber = process.env.ISSUE_NUMBER;
            const currentIteration = parseInt(process.env.CURRENT_ITERATION);
            const nextIteration = currentIteration + 1;

            if (!issueNumber) {
              console.log('âš ï¸ No issue number found in PR, cannot trigger iteration');
              return;
            }

            // Parse improvement suggestions
            let suggestions = [];
            try {
              suggestions = JSON.parse(process.env.IMPROVEMENT_SUGGESTIONS || '[]');
            } catch (e) {
              console.log('âš ï¸ Failed to parse improvement suggestions:', e);
            }

            // Add iteration label to related issue
            const labelName = `ai-iteration-${nextIteration}`;

            // Check if label exists, create if not
            try {
              await github.rest.issues.getLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: labelName
              });
            } catch (e) {
              if (e.status === 404) {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: labelName,
                  color: 'fbca04',
                  description: `AI iteration ${nextIteration}`
                });
              }
            }

            // Add label to issue
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(issueNumber),
              labels: [labelName]
            });

            // Close current PR with comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `ðŸ”„ Closing this PR to generate improved version based on AI feedback.\n\n**Iteration ${nextIteration} will address:**\n${suggestions.map(s => `- ${s}`).join('\n')}`
            });

            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              state: 'closed'
            });

            // Delete the branch
            if (prBranch) {
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${prBranch}`
                });
                console.log(`âœ… Deleted branch: ${prBranch}`);
              } catch (e) {
                console.log(`âš ï¸ Could not delete branch: ${e.message}`);
              }
            }

            // Trigger propose-fix workflow with feedback
            console.log(`ðŸ”„ Triggering propose-fix for issue #${issueNumber} with AI feedback (iteration ${nextIteration})`);

            // Get issue details to extract category
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(issueNumber)
            });

            // Find category label (format: category:xxx)
            const categoryLabel = issue.data.labels.find(l => l.name.startsWith('category:'));
            const category = categoryLabel
              ? categoryLabel.name.replace('category:', '')
              : 'outdated-docs';

            // Format suggestions as additional context
            const feedback = suggestions.length > 0
              ? `\n\n**AI Review Feedback (Iteration ${nextIteration}):**\n${suggestions.map(s => `- ${s}`).join('\n')}`
              : '';

            // Trigger workflow
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'propose-fix.yml',
              ref: 'main',
              inputs: {
                issue_number: issueNumber.toString(),
                category: category,
                ai_feedback: feedback
              }
            });

            console.log(`âœ… Triggered propose-fix with iteration ${nextIteration} feedback`);

      - name: Add labels based on decision
        if: steps.find-pr.outputs.found == 'true' && steps.ai-review.outputs.decision != 'REQUEST_CHANGES'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.find-pr.outputs.pr_number }}
          DECISION: ${{ steps.ai-review.outputs.decision }}
          CURRENT_ITERATION: ${{ steps.pr-details.outputs.iteration }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);
            const decision = process.env.DECISION;
            const currentIteration = parseInt(process.env.CURRENT_ITERATION);

            const labels = ['ai-reviewed'];

            if (decision === 'MERGE') {
              labels.push('auto-merged');

              // Add success label if this was after iterations
              if (currentIteration > 0) {
                labels.push('ai-improved');
              }
            } else if (decision === 'NEEDS_REVIEW') {
              labels.push('needs-human-review');

              // Add max-iterations-reached if applicable
              if (currentIteration >= 2) {
                labels.push('max-iterations-reached');
              }
            }

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              labels: labels
            });

      - name: Close related issue if merged
        if: steps.find-pr.outputs.found == 'true' && steps.ai-review.outputs.decision == 'MERGE'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.find-pr.outputs.pr_number }}
          CURRENT_ITERATION: ${{ steps.pr-details.outputs.iteration }}
          CONFIDENCE: ${{ steps.ai-review.outputs.confidence }}
          PR_BODY: ${{ steps.pr-details.outputs.pr_body }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);
            const prBody = process.env.PR_BODY || '';
            const currentIteration = parseInt(process.env.CURRENT_ITERATION);
            const confidence = parseInt(process.env.CONFIDENCE);

            // Extract issue number from "Fixes: #123" pattern
            const issueMatch = prBody.match(/\*\*Fixes:\*\*\s*#(\d+)/);

            if (issueMatch) {
              const issueNumber = parseInt(issueMatch[1]);

              let message = `âœ… Automaticky vyÅ™eÅ¡eno a mergnutÃ© v PR #${prNumber}\n\n`;
              message += `ðŸ¤– AI Review schvÃ¡lilo zmÄ›ny s ${confidence}% dÅ¯vÄ›rou.`;

              if (currentIteration > 0) {
                message += `\n\nðŸ”„ VyÅ™eÅ¡eno po ${currentIteration} AI iteraci${currentIteration > 1 ? 'ch' : ''} (automatickÃ© zlepÅ¡enÃ­ kvality).`;
              }

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: message
              });

              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                state: 'closed'
              });

              console.log(`Closed issue #${issueNumber}${currentIteration > 0 ? ` (after ${currentIteration} iterations)` : ''}`);
            }

      - name: Upload review artifact
        if: always() && steps.find-pr.outputs.found == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ai-review-${{ steps.find-pr.outputs.pr_number }}
          path: |
            ai-review.json
            pr-data.json
          retention-days: 30
          if-no-files-found: ignore
