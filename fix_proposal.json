{
  "analysis": "The Keboola core documentation is missing crucial information about the Jobs API, specifically how to run transformations programmatically. The current docs show job polling for Storage API operations (export-async, tables-async) but don't document the Jobs API endpoint for triggering transformations. This is a significant gap as running transformations is a common use case. Additionally, the dataapp-dev skill references the Jobs API workflow but the core docs don't provide the necessary endpoints and patterns.",
  "changes": [
    {
      "file": "claude/keboola-core/SKILL.md",
      "section": "After Storage API section, before Common Pitfalls",
      "current": null,
      "proposed": "---\n\n<!-- Source: 04-jobs-api.md -->\n\n# Jobs API\n\n## Running Transformations\n\nThe Jobs API allows you to programmatically trigger transformations and other components.\n\n### Trigger a Transformation\n\n```python\nimport requests\nimport os\nimport time\n\nstack_url = os.environ.get(\"KEBOOLA_STACK_URL\", \"connection.keboola.com\")\ntoken = os.environ[\"KEBOOLA_TOKEN\"]\n\n# Start a transformation job\nresponse = requests.post(\n    f\"https://{stack_url}/v2/storage/jobs\",\n    headers={\n        \"X-StorageApi-Token\": token,\n        \"Content-Type\": \"application/json\"\n    },\n    json={\n        \"component\": \"keboola.snowflake-transformation\",\n        \"config\": \"12345\",  # Your transformation config ID\n        \"mode\": \"run\"\n    }\n)\n\nif response.status_code != 201:\n    raise Exception(f\"Failed to start job: {response.text}\")\n\njob_id = response.json()[\"id\"]\nprint(f\"Started job {job_id}\")\n\n# Poll for completion\nwhile True:\n    job_response = requests.get(\n        f\"https://{stack_url}/v2/storage/jobs/{job_id}\",\n        headers={\"X-StorageApi-Token\": token}\n    )\n    \n    job = job_response.json()\n    status = job[\"status\"]\n    \n    if status == \"success\":\n        print(\"Transformation completed successfully\")\n        break\n    elif status == \"error\":\n        error_msg = job.get(\"result\", {}).get(\"message\", \"Unknown error\")\n        raise Exception(f\"Transformation failed: {error_msg}\")\n    elif status in [\"waiting\", \"processing\"]:\n        print(f\"Job status: {status}\")\n        time.sleep(5)\n    else:\n        raise Exception(f\"Unexpected job status: {status}\")\n```\n\n### Get Component Configuration ID\n\nTo run a transformation, you need its configuration ID:\n\n```python\n# List all configurations for a component\nresponse = requests.get(\n    f\"https://{stack_url}/v2/storage/components/keboola.snowflake-transformation/configs\",\n    headers={\"X-StorageApi-Token\": token}\n)\n\nconfigs = response.json()\nfor config in configs:\n    print(f\"{config['id']}: {config['name']}\")\n```\n\n### Trigger Specific Transformation within Config\n\nIf your configuration has multiple transformations, you can run specific ones:\n\n```python\nresponse = requests.post(\n    f\"https://{stack_url}/v2/storage/jobs\",\n    headers={\n        \"X-StorageApi-Token\": token,\n        \"Content-Type\": \"application/json\"\n    },\n    json={\n        \"component\": \"keboola.snowflake-transformation\",\n        \"config\": \"12345\",\n        \"mode\": \"run\",\n        \"configData\": {\n            \"parameters\": {\n                \"blocks\": [\"transformation_name\"]  # Optional: run specific blocks\n            }\n        }\n    }\n)\n```\n\n### Run Multiple Transformations Sequentially\n\n```python\ndef run_transformation(config_id, component=\"keboola.snowflake-transformation\"):\n    \"\"\"Run a transformation and wait for completion.\"\"\"\n    # Start job\n    response = requests.post(\n        f\"https://{stack_url}/v2/storage/jobs\",\n        headers={\n            \"X-StorageApi-Token\": token,\n            \"Content-Type\": \"application/json\"\n        },\n        json={\n            \"component\": component,\n            \"config\": config_id,\n            \"mode\": \"run\"\n        }\n    )\n    \n    if response.status_code != 201:\n        raise Exception(f\"Failed to start job: {response.text}\")\n    \n    job_id = response.json()[\"id\"]\n    \n    # Wait for completion\n    while True:\n        job_response = requests.get(\n            f\"https://{stack_url}/v2/storage/jobs/{job_id}\",\n            headers={\"X-StorageApi-Token\": token}\n        )\n        \n        job = job_response.json()\n        \n        if job[\"status\"] == \"success\":\n            return job\n        elif job[\"status\"] == \"error\":\n            error_msg = job.get(\"result\", {}).get(\"message\", \"Unknown error\")\n            raise Exception(f\"Job {job_id} failed: {error_msg}\")\n        \n        time.sleep(5)\n\n# Run transformations in sequence\ntransformations = [\"12345\", \"12346\", \"12347\"]\n\nfor config_id in transformations:\n    print(f\"Running transformation {config_id}...\")\n    result = run_transformation(config_id)\n    print(f\"Completed in {result.get('runTime', 0)}s\")\n```\n\n### Common Component Types\n\n- **Transformations**:\n  - `keboola.snowflake-transformation`\n  - `keboola.python-transformation-v2`\n  - `keboola.r-transformation-v2`\n  - `transformation` (legacy SQL transformations)\n\n- **Extractors** (examples):\n  - `keboola.ex-db-snowflake`\n  - `keboola.ex-google-analytics-v4`\n  - `keboola.ex-aws-s3`\n\n- **Writers** (examples):\n  - `keboola.wr-db-snowflake`\n  - `keboola.wr-google-sheets`\n\n### Job Status Reference\n\n- `waiting`: Job is queued\n- `processing`: Job is currently running\n- `success`: Job completed successfully\n- `error`: Job failed\n- `cancelled`: Job was cancelled\n- `terminating`: Job is being terminated\n- `terminated`: Job was terminated\n\n### Error Handling Best Practices\n\n```python\ndef run_job_with_retry(component, config_id, max_retries=3):\n    \"\"\"Run job with retry logic for transient failures.\"\"\"\n    for attempt in range(max_retries):\n        try:\n            response = requests.post(\n                f\"https://{stack_url}/v2/storage/jobs\",\n                headers={\n                    \"X-StorageApi-Token\": token,\n                    \"Content-Type\": \"application/json\"\n                },\n                json={\n                    \"component\": component,\n                    \"config\": config_id,\n                    \"mode\": \"run\"\n                },\n                timeout=30\n            )\n            \n            if response.status_code == 201:\n                job_id = response.json()[\"id\"]\n                \n                # Poll for completion with timeout\n                start_time = time.time()\n                timeout = 3600  # 1 hour\n                \n                while time.time() - start_time < timeout:\n                    job_response = requests.get(\n                        f\"https://{stack_url}/v2/storage/jobs/{job_id}\",\n                        headers={\"X-StorageApi-Token\": token}\n                    )\n                    \n                    job = job_response.json()\n                    \n                    if job[\"status\"] == \"success\":\n                        return job\n                    elif job[\"status\"] == \"error\":\n                        error_msg = job.get(\"result\", {}).get(\"message\", \"Unknown error\")\n                        \n                        # Check if error is retryable\n                        if \"timeout\" in error_msg.lower() or \"connection\" in error_msg.lower():\n                            if attempt < max_retries - 1:\n                                print(f\"Transient error, retrying... (attempt {attempt + 1}/{max_retries})\")\n                                time.sleep(2 ** attempt)  # Exponential backoff\n                                break\n                        \n                        raise Exception(f\"Job failed: {error_msg}\")\n                    \n                    time.sleep(5)\n                \n                raise TimeoutError(f\"Job {job_id} did not complete within {timeout}s\")\n            \n            elif response.status_code == 429:\n                # Rate limited\n                if attempt < max_retries - 1:\n                    wait_time = 2 ** attempt\n                    print(f\"Rate limited, waiting {wait_time}s...\")\n                    time.sleep(wait_time)\n                else:\n                    raise Exception(\"Rate limit exceeded\")\n            else:\n                raise Exception(f\"Failed to start job: {response.status_code} {response.text}\")\n                \n        except requests.exceptions.Timeout:\n            if attempt < max_retries - 1:\n                print(f\"Request timeout, retrying... (attempt {attempt + 1}/{max_retries})\")\n                time.sleep(2 ** attempt)\n            else:\n                raise\n    \n    raise Exception(f\"Job failed after {max_retries} attempts\")\n```\n\n",
      "reasoning": "Adds comprehensive Jobs API documentation showing how to run transformations, handle job polling, and manage errors. This fills the gap identified in the issue and provides essential patterns that developers need when working with Keboola programmatically."
    },
    {
      "file": "claude/keboola-core/SKILL.md",
      "section": "Common Pitfalls section - add new pitfall after item 5",
      "current": null,
      "proposed": "\n## 6. Not Handling Job Timeouts\n\n**Problem**: Long-running transformations timing out without proper handling\n\n**Solution**: Implement timeout logic and provide feedback:\n\n```python\ndef wait_for_job_with_timeout(job_id, timeout=3600, poll_interval=5):\n    \"\"\"Wait for job completion with configurable timeout.\"\"\"\n    start_time = time.time()\n    last_status = None\n    \n    while time.time() - start_time < timeout:\n        response = requests.get(\n            f\"https://{stack_url}/v2/storage/jobs/{job_id}\",\n            headers={\"X-StorageApi-Token\": token}\n        )\n        \n        job = response.json()\n        status = job[\"status\"]\n        \n        # Log status changes\n        if status != last_status:\n            elapsed = int(time.time() - start_time)\n            print(f\"[{elapsed}s] Job status: {status}\")\n            last_status = status\n        \n        if status == \"success\":\n            return job\n        elif status == \"error\":\n            error_msg = job.get(\"result\", {}).get(\"message\", \"Unknown error\")\n            raise Exception(f\"Job {job_id} failed: {error_msg}\")\n        \n        time.sleep(poll_interval)\n    \n    # Timeout reached - job may still be running\n    raise TimeoutError(\n        f\"Job {job_id} did not complete within {timeout}s. \"\n        f\"Last status: {last_status}. Job may still be running in Keboola.\"\n    )\n```\n\n## 7. Using Wrong Component Names\n\n**Problem**: Using incorrect component IDs when triggering jobs\n\n**Solution**: Always verify component names from the UI or API:\n\n```python\n# \u274c WRONG - using old or incorrect component name\nresponse = requests.post(\n    f\"https://{stack_url}/v2/storage/jobs\",\n    json={\n        \"component\": \"transformation\",  # Legacy name\n        \"config\": \"12345\"\n    }\n)\n\n# \u2705 CORRECT - use current component name\nresponse = requests.post(\n    f\"https://{stack_url}/v2/storage/jobs\",\n    headers={\n        \"X-StorageApi-Token\": token,\n        \"Content-Type\": \"application/json\"\n    },\n    json={\n        \"component\": \"keboola.snowflake-transformation\",\n        \"config\": \"12345\",\n        \"mode\": \"run\"\n    }\n)\n\n# Verify component exists\ncomponents_response = requests.get(\n    f\"https://{stack_url}/v2/storage/components\",\n    headers={\"X-StorageApi-Token\": token}\n)\n\ncomponent_ids = [c[\"id\"] for c in components_response.json()]\nif \"keboola.snowflake-transformation\" not in component_ids:\n    print(\"Component not available in this project\")\n```\n\n",
      "reasoning": "Adds two new common pitfalls specifically related to Jobs API usage: handling timeouts for long-running jobs and using correct component names. These are frequent issues developers encounter when working with the Jobs API."
    }
  ],
  "pr_title": "Add Jobs API documentation for running transformations",
  "pr_description": "## Summary\nAdds comprehensive Jobs API documentation to address TS-003: Missing Jobs API Documentation for Running Transformations.\n\n## Changes Made\n\n### New Section: Jobs API (04-jobs-api.md)\nAdded complete documentation covering:\n\n1. **Running Transformations**\n   - Basic transformation execution with job polling\n   - Getting component configuration IDs\n   - Running specific transformations within a config\n   - Sequential execution patterns\n\n2. **Component Reference**\n   - Common transformation types (Snowflake, Python, R)\n   - Extractor examples\n   - Writer examples\n\n3. **Job Status Reference**\n   - Complete list of job statuses and their meanings\n\n4. **Error Handling**\n   - Retry logic for transient failures\n   - Timeout handling\n   - Rate limit management\n   - Exponential backoff patterns\n\n### Updated Common Pitfalls\nAdded two new pitfalls:\n\n6. **Not Handling Job Timeouts**: Shows proper timeout implementation with status logging\n7. **Using Wrong Component Names**: Demonstrates how to verify and use correct component IDs\n\n## Why These Changes\n\n- The current documentation only covers Storage API operations (export-async, tables-async)\n- Developers need to programmatically trigger transformations, which requires the Jobs API\n- The dataapp-dev skill references Jobs API workflows but lacks the foundational documentation\n- Running transformations is a common use case in data pipelines and automation\n\n## Code Examples\n\nAll examples follow existing documentation patterns:\n- Use environment variables for credentials and stack URLs\n- Include proper error handling\n- Show both basic and advanced patterns\n- Follow Python best practices\n\n## Testing\n\nDocumentation includes:\n- Working code examples that can be copy-pasted\n- Error handling for common failure scenarios\n- Timeout management for long-running jobs\n- Retry logic for transient failures\n\n## Related Issues\n\nCloses TS-003"
}